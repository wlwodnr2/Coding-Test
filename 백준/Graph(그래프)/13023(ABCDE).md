예제 입/출력 1,2
-----------------
![image](https://user-images.githubusercontent.com/64742982/162353009-d1d25ee9-b3da-45c4-b755-5bf1b95720bb.png)

예제 입/출력 3,4
-----------------
![image](https://user-images.githubusercontent.com/64742982/162353039-f4651651-1ede-4418-a630-642dad2b5025.png)

문제에 관한 간단한 해법
------------------------

**1. 단순한 Backtracking 사용하면 시간 복잡도때문에 망한다.**

    1. Backtracking은 완전 탐색으로 배열 크기가 2000인 경우 시간 복잡도가 어마무시하다.
    2. 4층까지 들어가야 하는 경우기 때문에 O(2000^4) 하면 2초 안에 절대 맞출 수 없다.

**2. 첫 번째 풀이**

    1. 예를 들어 0,1이 추가 될 경우
    2. 배열 0번에 1을 추가하고 count++를 해준다.
    3. 배열 1번에도 0을 추가하고 count++를 해준다.
    4. 재귀함수로 들어갈 때 시작 번호의 관계 길이 만큼 for문을 돌린다. (시간 복잡도 훨씬 줄어듬)
    5. 하지만 배열을 2000x2000 사용했기 때문에 메모리 차지가 엄청나다. 

**3. 두 번째 풀이**

    1. malloc의 동적 배열 사용
    2. 구조체 하나에 친구인 번호, 다음 노드를 넣어준다.
    3. 그 구조체 포인터를 포함한 구조체 하나 생성
    4. 추가 할 때마다 친구인 번호와 다음 친구 번호를 지정해주며 저장.
    5. 예를 들어 0번 친구가 1,3,5번 친구와 친구라면 구조체 배열 0번은 1->3->5->NULL 이런식으로 가리키고 있다.
    6. 재귀 함수에서 NULL이 나올때까지 돌리면 된다. 
