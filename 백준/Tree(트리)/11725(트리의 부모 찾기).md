예제 입/출력 1,2
--------------------
![image](https://user-images.githubusercontent.com/64742982/163814210-a7cfd569-2fd2-4f49-ab7f-83919b07f17e.png)

문제에 관한 간단한 해법
--------------------

N의 범위가 0이상 100,000 이하이다. 평소처럼 map[MAX][MAX] 2차원 배열을 만든다면 메모리 초과가 발생한다. 

2차원 배열을 안 쓰고 어떻게 풀어야 될지 많이 고민했던 것 같다.

결국에 2차원 배열을 쓰지 않으면 1차원 배열을 N만큼 생성한 후 연결 리스트로 연결되어있는 노드들을 추가하는 것이었다. 

2차원 배열은 공간을 낭비하지만 연결리스트로 동적 할당을 계속 해줄 경우에는 공간을 낭비하지 않게 된다. 

**1. Node는 계속 추가하는 동적 공간일 뿐. 우리에게 필요한 1차원 배열은 Head와 Tail을 가르키는 구조체가 있어야 한다.**

    1. 연결된 두 노드의 값을 입력 받을 때 서로의 1차원 배열에 추가해주면서 Head와 Tail의 위치를 조정해준다.
    2. 이진 트리일 경우에는 고작 해봐야 1차원 배열에 3개의 연결 리스트가 추가된다. 

**2. 또한 이 문제는 부모를 구하는 문제기 때문에 BFS를 사용하는 것이 유리하다.**

    1. 깊게 가는 것도 좋지만 BFS를 통해 층마다 훑으면서 부모를 추가해주는 것이 좋다고 생각했다.
    2. parent라는 동적 배열을 N의 크기만큼 생성해서 지속적으로 갱신해줬다.

**3. 2차원 배열을 연결 리스트로 구현하는 것이 어려웠던 것 같다.**
