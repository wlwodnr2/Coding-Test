예제 입/출력 1
----------------------
![image](https://user-images.githubusercontent.com/64742982/159193952-0fd7537d-7597-4b80-8de6-e6d96999838d.png)


예제 입/출력 2
----------------------
![image](https://user-images.githubusercontent.com/64742982/159193968-d191304a-8917-4910-809f-140a3252d8c3.png)


예제 입/출력 3
----------------------
![image](https://user-images.githubusercontent.com/64742982/159193980-2eda0e7d-00b7-4ca4-8464-995b1d18f44c.png)


문제 답변 순서도
------------
![image](https://user-images.githubusercontent.com/64742982/159193931-34395d1c-be37-4bbe-bc9e-f52921c736e0.png)


내가 생각했던 문제 해결
-----------------------

**1. 연결 리스트를 사용한다.**

  1. 연결 리스트에는 이전을 가르키는 Before과 다음을 가르키는 next가 존재해야 한다.

**2. P인 경우**

  1. 새로운 노드 생성, 새로운 노드의 before는 커서 위치의 노드이다. 
  2. 만약 끝이라면 -> 커서의 다음 노드 = 새로운 노드이다 , 그리고 커서 위치를 새로운 노드로 변경
  3. 끝이 아니라면 -> 새로운 노드의 다음이 커서의 다음이고, 커서의 다음의 이전이 새로운 노드이다. 그리고 위는 동일 

**3. L인 경우**

  1. 맨 앞만 아니면 이동 가능

**4. D인 경우**

  1. 맨 끝만 아니면 이동 가능

**5. B인 경우**

  1. 맨 앞이 아니면 문자를 삭제할 수 있다.
  2. 삭제할 노드에 커서 위치의 노드를 넣고
  3. 커서는 삭제할 노드의 이전으로 돌아간다. 
  4. 그런 다음에 free를 통해 삭제 진행 

블로그에 있던 문제 해결
----------------------

**1. 왼쪽 배열 오른쪽 배열 두 개를 사용**

**2. P인 경우**

  1. 왼쪽 배열의 index++ 하면서 데이터 추가

**3. L인 경우**

  1. 맨 앞이 아니라면 ~ 오른쪽 배열의 맨 끝에 왼쪽 배열의 마지막 데이터를 넣는다. 
  2. 그리고 왼쪽 배열의 마지막 데이터는 NULL

**4. D인 경우**

  1. 왼쪽 배열의 마지막 데이터 다음에 오른쪽 배열의 첫 번째 데이터를 넣는다.
  2. 그리고 오른쪽 배열에 있던 데이터는 NULL

**5. B인 경우**

  1. 왼쪽 배열의 데이터 NULL 
